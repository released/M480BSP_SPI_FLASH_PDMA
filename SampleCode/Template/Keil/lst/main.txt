; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;811    
;;;812    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;813    {
;;;814    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;815    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;816    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;817    	
;;;818    }
;;;819    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SPI_Master_RX_PDMA||, CODE, READONLY, ALIGN=2

                  SPI_Master_RX_PDMA PROC
;;;138    
;;;139    void SPI_Master_RX_PDMA(uint8_t* Rx , uint16_t len)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;140    {
;;;141    	uint32_t u32RegValue = 0;
;;;142    	uint32_t u32Abort = 0;	
;;;143    	
;;;144        PDMA_Open(PDMA, (1 << SPI_MASTER_RX_DMA_CH));
000004  4e23              LDR      r6,|L3.148|
000006  460d              MOV      r5,r1                 ;140
000008  4607              MOV      r7,r0                 ;140
00000a  f44f6480          MOV      r4,#0x400
00000e  4621              MOV      r1,r4
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       PDMA_Open
;;;145    
;;;146    	//RX	
;;;147        PDMA_SetTransferCnt(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, len);
000016  462b              MOV      r3,r5
000018  2200              MOVS     r2,#0
00001a  210a              MOVS     r1,#0xa
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       PDMA_SetTransferCnt
;;;148        /* Set source/destination address and attributes */
;;;149        PDMA_SetTransferAddr(PDMA,SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI_FLASH_PORT->RX, PDMA_SAR_FIX, (uint32_t)Rx, PDMA_DAR_INC);
000022  2500              MOVS     r5,#0
000024  e9cd7500          STRD     r7,r5,[sp,#0]
000028  f44f7340          MOV      r3,#0x300
00002c  4a1a              LDR      r2,|L3.152|
00002e  210a              MOVS     r1,#0xa
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       PDMA_SetTransferAddr
;;;150        /* Set request source; set basic mode. */
;;;151        PDMA_SetTransferMode(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_SPI0_RX, FALSE, 0);
000036  2300              MOVS     r3,#0
000038  2217              MOVS     r2,#0x17
00003a  210a              MOVS     r1,#0xa
00003c  4630              MOV      r0,r6
00003e  9500              STR      r5,[sp,#0]
000040  f7fffffe          BL       PDMA_SetTransferMode
;;;152        /* Single request type. SPI only support PDMA single request type. */
;;;153        PDMA_SetBurstType(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000044  2300              MOVS     r3,#0
000046  2204              MOVS     r2,#4
000048  210a              MOVS     r1,#0xa
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       PDMA_SetBurstType
;;;154        /* Disable table interrupt */
;;;155        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000050  f8560fa0          LDR      r0,[r6,#0xa0]!
000054  f0400080          ORR      r0,r0,#0x80
000058  6030              STR      r0,[r6,#0]
;;;156    
;;;157        SPI_TRIGGER_RX_PDMA(SPI_FLASH_PORT);
00005a  4d0f              LDR      r5,|L3.152|
00005c  3d30              SUBS     r5,r5,#0x30
00005e  68e8              LDR      r0,[r5,#0xc]
000060  f0400002          ORR      r0,r0,#2
000064  60e8              STR      r0,[r5,#0xc]
;;;158    
;;;159        while(1)
;;;160        {
;;;161            /* Get interrupt status */
;;;162            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;163            /* Check the DMA transfer done interrupt flag */
;;;164            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;165            {
;;;166                /* Check the PDMA transfer done interrupt flags */
;;;167                if((PDMA_GET_TD_STS(PDMA) & (1 << SPI_MASTER_RX_DMA_CH)) == (1 << SPI_MASTER_RX_DMA_CH))
000066  490d              LDR      r1,|L3.156|
000068  4a0c              LDR      r2,|L3.156|
00006a  3108              ADDS     r1,r1,#8
                  |L3.108|
00006c  6810              LDR      r0,[r2,#0]            ;162
00006e  0783              LSLS     r3,r0,#30             ;164
000070  d5fc              BPL      |L3.108|
000072  680b              LDR      r3,[r1,#0]
000074  055b              LSLS     r3,r3,#21
000076  d506              BPL      |L3.134|
;;;168                {
;;;169                    /* Clear the DMA transfer done flags */
;;;170                    PDMA_CLR_TD_FLAG(PDMA,1 << SPI_MASTER_RX_DMA_CH);
000078  600c              STR      r4,[r1,#0]
;;;171                    /* Disable SPI PDMA RX function */
;;;172                    SPI_DISABLE_RX_PDMA(SPI_FLASH_PORT);
00007a  68e8              LDR      r0,[r5,#0xc]
00007c  f0200002          BIC      r0,r0,#2
000080  60e8              STR      r0,[r5,#0xc]
                  |L3.130|
;;;173                    break;
;;;174                }
;;;175    
;;;176                /* Check the DMA transfer abort interrupt flag */
;;;177                if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;178                {
;;;179                    /* Get the target abort flag */
;;;180                    u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;181                    /* Clear the target abort flag */
;;;182                    PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;183                    break;
;;;184                }
;;;185            }
;;;186        }
;;;187    
;;;188    }
000082  e8bd81fc          POP      {r2-r8,pc}
                  |L3.134|
000086  07c0              LSLS     r0,r0,#31             ;177
000088  d0f0              BEQ      |L3.108|
00008a  4904              LDR      r1,|L3.156|
00008c  1d09              ADDS     r1,r1,#4              ;180
00008e  6808              LDR      r0,[r1,#0]            ;180
000090  6008              STR      r0,[r1,#0]            ;182
000092  e7f6              B        |L3.130|
;;;189    
                          ENDP

                  |L3.148|
                          DCD      0x40008000
                  |L3.152|
                          DCD      0x40061030
                  |L3.156|
                          DCD      0x4000841c

                          AREA ||i.SPI_Master_TX_PDMA||, CODE, READONLY, ALIGN=2

                  SPI_Master_TX_PDMA PROC
;;;189    
;;;190    void SPI_Master_TX_PDMA(uint8_t* Tx , uint16_t len)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;191    {
;;;192    	uint32_t u32RegValue = 0;
;;;193    	uint32_t u32Abort = 0;	
;;;194    
;;;195        PDMA_Open(PDMA, (1 << SPI_MASTER_TX_DMA_CH));
000004  4d24              LDR      r5,|L4.152|
000006  460f              MOV      r7,r1                 ;191
000008  4606              MOV      r6,r0                 ;191
00000a  f44f7400          MOV      r4,#0x200
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       PDMA_Open
;;;196    
;;;197    	//TX
;;;198        PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, len);
000016  463b              MOV      r3,r7
000018  2200              MOVS     r2,#0
00001a  2109              MOVS     r1,#9
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       PDMA_SetTransferCnt
;;;199        /* Set source/destination address and attributes */
;;;200        PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)Tx, PDMA_SAR_INC, (uint32_t)&SPI_FLASH_PORT->TX, PDMA_DAR_FIX);
000022  f44f6140          MOV      r1,#0xc00
000026  481d              LDR      r0,|L4.156|
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  2300              MOVS     r3,#0
00002e  4632              MOV      r2,r6
000030  2109              MOVS     r1,#9
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       PDMA_SetTransferAddr
;;;201        /* Set request source; set basic mode. */
;;;202        PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI0_TX, FALSE, 0);
000038  2000              MOVS     r0,#0
00003a  4603              MOV      r3,r0
00003c  9000              STR      r0,[sp,#0]
00003e  2216              MOVS     r2,#0x16
000040  2109              MOVS     r1,#9
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       PDMA_SetTransferMode
;;;203        /* Single request type. SPI only support PDMA single request type. */
;;;204        PDMA_SetBurstType(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000048  2300              MOVS     r3,#0
00004a  2204              MOVS     r2,#4
00004c  2109              MOVS     r1,#9
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       PDMA_SetBurstType
;;;205        /* Disable table interrupt */
;;;206        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000054  f8550f90          LDR      r0,[r5,#0x90]!
000058  f0400080          ORR      r0,r0,#0x80
00005c  6028              STR      r0,[r5,#0]
;;;207    
;;;208        SPI_TRIGGER_TX_PDMA(SPI_FLASH_PORT);
00005e  4d0f              LDR      r5,|L4.156|
000060  3d20              SUBS     r5,r5,#0x20
000062  68e8              LDR      r0,[r5,#0xc]
000064  f0400001          ORR      r0,r0,#1
000068  60e8              STR      r0,[r5,#0xc]
;;;209    
;;;210        while(1)
;;;211        {
;;;212            /* Get interrupt status */
;;;213            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;214            /* Check the DMA transfer done interrupt flag */
;;;215            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;216            {
;;;217                /* Check the PDMA transfer done interrupt flags */
;;;218                if((PDMA_GET_TD_STS(PDMA) & (1 << SPI_MASTER_TX_DMA_CH)) == (1 << SPI_MASTER_TX_DMA_CH))
00006a  490d              LDR      r1,|L4.160|
00006c  4a0c              LDR      r2,|L4.160|
00006e  3108              ADDS     r1,r1,#8
                  |L4.112|
000070  6810              LDR      r0,[r2,#0]            ;213
000072  0783              LSLS     r3,r0,#30             ;215
000074  d5fc              BPL      |L4.112|
000076  680b              LDR      r3,[r1,#0]
000078  059b              LSLS     r3,r3,#22
00007a  d506              BPL      |L4.138|
;;;219                {
;;;220                    /* Clear the DMA transfer done flags */
;;;221                    PDMA_CLR_TD_FLAG(PDMA,1 << SPI_MASTER_TX_DMA_CH);
00007c  600c              STR      r4,[r1,#0]
;;;222                    /* Disable SPI PDMA TX function */
;;;223                    SPI_DISABLE_TX_PDMA(SPI_FLASH_PORT);
00007e  68e8              LDR      r0,[r5,#0xc]
000080  f0200001          BIC      r0,r0,#1
000084  60e8              STR      r0,[r5,#0xc]
                  |L4.134|
;;;224                    break;
;;;225                }
;;;226    
;;;227                /* Check the DMA transfer abort interrupt flag */
;;;228                if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;229                {
;;;230                    /* Get the target abort flag */
;;;231                    u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;232                    /* Clear the target abort flag */
;;;233                    PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;234                    break;
;;;235                }
;;;236            }
;;;237        }
;;;238    
;;;239    }
000086  e8bd81fc          POP      {r2-r8,pc}
                  |L4.138|
00008a  07c0              LSLS     r0,r0,#31             ;228
00008c  d0f0              BEQ      |L4.112|
00008e  4904              LDR      r1,|L4.160|
000090  1d09              ADDS     r1,r1,#4              ;231
000092  6808              LDR      r0,[r1,#0]            ;231
000094  6008              STR      r0,[r1,#0]            ;233
000096  e7f6              B        |L4.134|
;;;240    
                          ENDP

                  |L4.152|
                          DCD      0x40008000
                  |L4.156|
                          DCD      0x40061020
                  |L4.160|
                          DCD      0x4000841c

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;819    
;;;820    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L5.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L5.10|
;;;821    {
;;;822        /*---------------------------------------------------------------------------------------------------------*/
;;;823        /* Init System Clock                                                                                       */
;;;824        /*---------------------------------------------------------------------------------------------------------*/
;;;825        /* Unlock protected registers */
;;;826        SYS_UnlockReg();
;;;827    
;;;828        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;829        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;830    
;;;831        /* Enable External XTAL (4~24 MHz) */
;;;832        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;833    
;;;834        /* Waiting for 12MHz clock ready */
;;;835        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;836    
;;;837        /* Set core clock as PLL_CLOCK from PLL */
;;;838        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481d              LDR      r0,|L5.176|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;839        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;840        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;841    
;;;842        /* Enable UART clock */
;;;843        CLK_EnableModuleClock(UART0_MODULE);
000046  4e1b              LDR      r6,|L5.180|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;844    
;;;845        /* Select UART clock source from HXT */
;;;846        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;847    
;;;848        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000058  4e17              LDR      r6,|L5.184|
00005a  2200              MOVS     r2,#0
00005c  2120              MOVS     r1,#0x20
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;849        CLK_EnableModuleClock(SPI0_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;850    
;;;851        CLK_EnableModuleClock(PDMA_MODULE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       CLK_EnableModuleClock
;;;852    
;;;853    	TIMER0_HW_Init();
000070  f7fffffe          BL       TIMER0_HW_Init
;;;854    	TIMER1_HW_Init();
000074  f7fffffe          BL       TIMER1_HW_Init
;;;855    	
;;;856        /* Update System Core Clock */
;;;857        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;858        SystemCoreClockUpdate();
000078  f7fffffe          BL       SystemCoreClockUpdate
;;;859    
;;;860        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;861        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00007c  6be0              LDR      r0,[r4,#0x3c]
00007e  f420007f          BIC      r0,r0,#0xff0000
000082  63e0              STR      r0,[r4,#0x3c]
;;;862        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000084  6be0              LDR      r0,[r4,#0x3c]
000086  f44000cc          ORR      r0,r0,#0x660000
00008a  63e0              STR      r0,[r4,#0x3c]
;;;863    
;;;864    	//conflict with EVM UART pin , PB12/PB13
;;;865    	#if defined (CUSTOM_SPI_FLASH_PIN)	
;;;866    
;;;867        /* Setup SPI0 multi-function pins */
;;;868        SYS->GPB_MFPH |= SYS_GPB_MFPH_PB12MFP_SPI0_MOSI | SYS_GPB_MFPH_PB13MFP_SPI0_MISO | SYS_GPB_MFPH_PB14MFP_SPI0_CLK | SYS_GPB_MFPH_PB15MFP_SPI0_SS;
;;;869    
;;;870        /* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;871        PB->SMTEN |= GPIO_SMTEN_SMTEN14_Msk;
;;;872    
;;;873        /* Enable SPI0 I/O high slew rate */
;;;874        GPIO_SetSlewCtl(PB, 0xF, GPIO_SLEWCTL_HIGH);
;;;875    
;;;876    	#else
;;;877        /* Setup SPI0 multi-function pins */
;;;878        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_SPI0_MOSI | SYS_GPA_MFPL_PA1MFP_SPI0_MISO | SYS_GPA_MFPL_PA2MFP_SPI0_CLK | SYS_GPA_MFPL_PA3MFP_SPI0_SS;
00008c  6b20              LDR      r0,[r4,#0x30]
00008e  f2444144          MOV      r1,#0x4444
000092  4308              ORRS     r0,r0,r1
000094  6320              STR      r0,[r4,#0x30]
;;;879    
;;;880        /* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;881        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
000096  6a68              LDR      r0,[r5,#0x24]
000098  f0400004          ORR      r0,r0,#4
00009c  6268              STR      r0,[r5,#0x24]
;;;882    
;;;883        /* Enable SPI0 I/O high slew rate */
;;;884        GPIO_SetSlewCtl(PA, 0xF, GPIO_SLEWCTL_HIGH);
00009e  2201              MOVS     r2,#1
0000a0  210f              MOVS     r1,#0xf
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       GPIO_SetSlewCtl
0000a8  2000              MOVS     r0,#0
0000aa  f8c40100          STR      r0,[r4,#0x100]
;;;885    	#endif
;;;886    	
;;;887        /* Lock protected registers */
;;;888        SYS_LockReg();
;;;889    }
0000ae  bd70              POP      {r4-r6,pc}
;;;890    
                          ENDP

                  |L5.176|
                          DCD      0x0b71b000
                  |L5.180|
                          DCD      0x57803d10
                  |L5.184|
                          DCD      0x6640000d

                          AREA ||i.SpiFlash_ChipErase||, CODE, READONLY, ALIGN=2

                  SpiFlash_ChipErase PROC
;;;271    
;;;272    void SpiFlash_ChipErase(void)
000000  4812              LDR      r0,|L6.76|
;;;273    {
;;;274        // /CS: active
;;;275        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  6881              LDR      r1,[r0,#8]
000004  f021010c          BIC      r1,r1,#0xc
000008  f0410101          ORR      r1,r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;276    
;;;277        // send Command: 0x06, Write enable
;;;278        SPI_WRITE_TX(SPI_FLASH_PORT, 0x06);
00000e  2106              MOVS     r1,#6
000010  6201              STR      r1,[r0,#0x20]
                  |L6.18|
;;;279    
;;;280        // wait tx finish
;;;281        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000012  6941              LDR      r1,[r0,#0x14]
000014  07c9              LSLS     r1,r1,#31
000016  d1fc              BNE      |L6.18|
;;;282    
;;;283        // /CS: de-active
;;;284        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
000018  6881              LDR      r1,[r0,#8]
00001a  f0210108          BIC      r1,r1,#8
00001e  f0410105          ORR      r1,r1,#5
000022  6081              STR      r1,[r0,#8]
;;;285    
;;;286        //////////////////////////////////////////
;;;287    
;;;288        // /CS: active
;;;289        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000024  6881              LDR      r1,[r0,#8]
000026  f021010c          BIC      r1,r1,#0xc
00002a  f0410101          ORR      r1,r1,#1
00002e  6081              STR      r1,[r0,#8]
;;;290    
;;;291        // send Command: 0xC7, Chip Erase
;;;292        SPI_WRITE_TX(SPI_FLASH_PORT, 0xC7);
000030  21c7              MOVS     r1,#0xc7
000032  6201              STR      r1,[r0,#0x20]
                  |L6.52|
;;;293    
;;;294        // wait tx finish
;;;295        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000034  6941              LDR      r1,[r0,#0x14]
000036  07c9              LSLS     r1,r1,#31
000038  d1fc              BNE      |L6.52|
;;;296    
;;;297        // /CS: de-active
;;;298        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
00003a  6881              LDR      r1,[r0,#8]
00003c  f0210108          BIC      r1,r1,#8
000040  f0410105          ORR      r1,r1,#5
000044  6081              STR      r1,[r0,#8]
;;;299    
;;;300        SPI_ClearRxFIFO(SPI_FLASH_PORT);
000046  f7ffbffe          B.W      SPI_ClearRxFIFO
;;;301    }
;;;302    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x40061000

                          AREA ||i.SpiFlash_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  SpiFlash_Init PROC
;;;504    
;;;505    void SpiFlash_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;506    {
;;;507        uint16_t u16ID = 0;
;;;508        uint16_t i = 0;
;;;509    	
;;;510        /* Configure SPI_FLASH_PORT as a master, MSB first, 8-bit transaction, SPI Mode-0 timing, clock is 20MHz */
;;;511        SPI_Open(SPI_FLASH_PORT, SPI_MASTER, SPI_MODE_0, 8, SPI_CLK_FREQ);
000002  4812              LDR      r0,|L7.76|
000004  4d12              LDR      r5,|L7.80|
000006  2400              MOVS     r4,#0                 ;508
000008  9000              STR      r0,[sp,#0]
00000a  2308              MOVS     r3,#8
00000c  2204              MOVS     r2,#4
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SPI_Open
;;;512    
;;;513        /* Disable auto SS function, control SS signal manually. */
;;;514        SPI_DisableAutoSS(SPI_FLASH_PORT);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       SPI_DisableAutoSS
;;;515        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
00001c  68a9              LDR      r1,[r5,#8]
00001e  f0210008          BIC      r0,r1,#8
000022  f0400105          ORR      r1,r0,#5
000026  60a9              STR      r1,[r5,#8]
;;;516    
;;;517    	u16ID = SpiFlash_ReadMidDid();
000028  f7fffffe          BL       SpiFlash_ReadMidDid
00002c  4601              MOV      r1,r0
;;;518    	printf("ID : 0x%2X\r\n" , u16ID);
00002e  a009              ADR      r0,|L7.84|
000030  f7fffffe          BL       __2printf
;;;519    
;;;520    	
;;;521    	//initial TX , RX data
;;;522        for (i=0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;523        {
;;;524            TxBuffer[i] = 0xFF;
000034  490b              LDR      r1,|L7.100|
000036  20ff              MOVS     r0,#0xff
;;;525            RxBuffer[i] = 0xFF;
000038  f5017280          ADD      r2,r1,#0x100
                  |L7.60|
00003c  5508              STRB     r0,[r1,r4]            ;524
00003e  5510              STRB     r0,[r2,r4]
000040  1c64              ADDS     r4,r4,#1
000042  b2a4              UXTH     r4,r4                 ;522
000044  2cff              CMP      r4,#0xff              ;522
000046  d9f9              BLS      |L7.60|
;;;526        }
;;;527    
;;;528    }
000048  bd38              POP      {r3-r5,pc}
;;;529    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      0x000f4240
                  |L7.80|
                          DCD      0x40061000
                  |L7.84|
000054  4944203a          DCB      "ID : 0x%2X\r\n",0
000058  20307825
00005c  32580d0a
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L7.100|
                          DCD      ||.bss||

                          AREA ||i.SpiFlash_NormalPageProgram||, CODE, READONLY, ALIGN=2

                  SpiFlash_NormalPageProgram PROC
;;;380    
;;;381    void SpiFlash_NormalPageProgram(uint32_t StartAddress, uint8_t *u8DataBuffer , uint8_t EnablePDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
;;;383        uint32_t i = 0;
;;;384    	
;;;385        // /CS: active
;;;386        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  4c21              LDR      r4,|L8.136|
000004  460b              MOV      r3,r1                 ;382
000006  4605              MOV      r5,r0                 ;382
000008  68a1              LDR      r1,[r4,#8]
00000a  2000              MOVS     r0,#0                 ;383
00000c  f021010c          BIC      r1,r1,#0xc
000010  f0410101          ORR      r1,r1,#1
000014  60a1              STR      r1,[r4,#8]
;;;387    
;;;388        // send Command: 0x06, Write enable
;;;389        SPI_WRITE_TX(SPI_FLASH_PORT, 0x06);
000016  2106              MOVS     r1,#6
000018  6221              STR      r1,[r4,#0x20]
                  |L8.26|
;;;390    
;;;391        // wait tx finish
;;;392        while(SPI_IS_BUSY(SPI_FLASH_PORT));
00001a  6961              LDR      r1,[r4,#0x14]
00001c  07c9              LSLS     r1,r1,#31
00001e  d1fc              BNE      |L8.26|
;;;393    
;;;394        // /CS: de-active
;;;395        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
000020  68a1              LDR      r1,[r4,#8]
000022  f0210108          BIC      r1,r1,#8
000026  f0410105          ORR      r1,r1,#5
00002a  60a1              STR      r1,[r4,#8]
;;;396    
;;;397    
;;;398        // /CS: active
;;;399        SPI_SET_SS_LOW(SPI_FLASH_PORT);
00002c  68a1              LDR      r1,[r4,#8]
00002e  f021010c          BIC      r1,r1,#0xc
000032  f0410101          ORR      r1,r1,#1
000036  60a1              STR      r1,[r4,#8]
;;;400    
;;;401        // send Command: 0x02, Page program
;;;402        SPI_WRITE_TX(SPI_FLASH_PORT, 0x02);
000038  2102              MOVS     r1,#2
00003a  6221              STR      r1,[r4,#0x20]
;;;403    
;;;404        // send 24-bit start address
;;;405        SPI_WRITE_TX(SPI_FLASH_PORT, (StartAddress>>16) & 0xFF);
00003c  f3c54107          UBFX     r1,r5,#16,#8
000040  6221              STR      r1,[r4,#0x20]
;;;406        SPI_WRITE_TX(SPI_FLASH_PORT, (StartAddress>>8)  & 0xFF);
000042  f3c52107          UBFX     r1,r5,#8,#8
000046  6221              STR      r1,[r4,#0x20]
;;;407        SPI_WRITE_TX(SPI_FLASH_PORT, StartAddress       & 0xFF);
000048  b2e9              UXTB     r1,r5
00004a  6221              STR      r1,[r4,#0x20]
;;;408    
;;;409    
;;;410        // write data
;;;411    	if (EnablePDMA)
00004c  b12a              CBZ      r2,|L8.90|
;;;412    	{
;;;413    		SPI_Master_TX_PDMA(u8DataBuffer , SPI_FLASH_PAGE_BYTE);
00004e  f44f7180          MOV      r1,#0x100
000052  4618              MOV      r0,r3
000054  f7fffffe          BL       SPI_Master_TX_PDMA
000058  e008              B        |L8.108|
                  |L8.90|
;;;414    	}
;;;415    	else
;;;416    	{
;;;417    	    while(1)
;;;418    	    {
;;;419    	        if(!SPI_GET_TX_FIFO_FULL_FLAG(SPI_FLASH_PORT))
00005a  6961              LDR      r1,[r4,#0x14]
00005c  0389              LSLS     r1,r1,#14
00005e  d4fc              BMI      |L8.90|
;;;420    	        {
;;;421    //				printf("%3d\r\n" , i);			
;;;422    	            SPI_WRITE_TX(SPI_FLASH_PORT, u8DataBuffer[i]);
000060  5c19              LDRB     r1,[r3,r0]
000062  6221              STR      r1,[r4,#0x20]
;;;423    	            if (i++ >= (SPI_FLASH_PAGE_BYTE-1) )
000064  4601              MOV      r1,r0
000066  1c40              ADDS     r0,r0,#1
000068  29ff              CMP      r1,#0xff
00006a  d3f6              BCC      |L8.90|
                  |L8.108|
;;;424    					break;				
;;;425    	        }
;;;426    	    }
;;;427    	}
;;;428    
;;;429        // wait tx finish
;;;430        while(SPI_IS_BUSY(SPI_FLASH_PORT));
00006c  6961              LDR      r1,[r4,#0x14]
00006e  07c9              LSLS     r1,r1,#31
000070  d1fc              BNE      |L8.108|
;;;431    
;;;432        // /CS: de-active
;;;433        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
000072  68a1              LDR      r1,[r4,#8]
000074  4620              MOV      r0,r4
000076  f0210108          BIC      r1,r1,#8
00007a  f0410105          ORR      r1,r1,#5
00007e  60a1              STR      r1,[r4,#8]
;;;434    
;;;435        SPI_ClearRxFIFO(SPI_FLASH_PORT);
000080  e8bd4070          POP      {r4-r6,lr}
000084  f7ffbffe          B.W      SPI_ClearRxFIFO
;;;436    }
;;;437    
                          ENDP

                  |L8.136|
                          DCD      0x40061000

                          AREA ||i.SpiFlash_NormalRead||, CODE, READONLY, ALIGN=2

                  SpiFlash_NormalRead PROC
;;;443    
;;;444    void SpiFlash_NormalRead(uint32_t StartAddress, uint8_t *u8DataBuffer , uint8_t EnablePDMA)
000000  b570              PUSH     {r4-r6,lr}
;;;445    {
;;;446        uint32_t i = 0;
;;;447    
;;;448        // /CS: active
;;;449        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  4c1a              LDR      r4,|L9.108|
000004  460d              MOV      r5,r1                 ;445
000006  4616              MOV      r6,r2                 ;445
000008  68a1              LDR      r1,[r4,#8]
00000a  f021010c          BIC      r1,r1,#0xc
00000e  f0410101          ORR      r1,r1,#1
000012  60a1              STR      r1,[r4,#8]
;;;450    
;;;451        // send Command: 0x03, Read data
;;;452        SPI_WRITE_TX(SPI_FLASH_PORT, 0x03);
000014  2103              MOVS     r1,#3
000016  6221              STR      r1,[r4,#0x20]
;;;453    
;;;454        // send 24-bit start address
;;;455        SPI_WRITE_TX(SPI_FLASH_PORT, (StartAddress>>16) & 0xFF);
000018  f3c04107          UBFX     r1,r0,#16,#8
00001c  6221              STR      r1,[r4,#0x20]
;;;456        SPI_WRITE_TX(SPI_FLASH_PORT, (StartAddress>>8)  & 0xFF);
00001e  f3c02107          UBFX     r1,r0,#8,#8
000022  6221              STR      r1,[r4,#0x20]
;;;457        SPI_WRITE_TX(SPI_FLASH_PORT, StartAddress       & 0xFF);
000024  b2c0              UXTB     r0,r0
000026  6220              STR      r0,[r4,#0x20]
                  |L9.40|
;;;458    
;;;459        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000028  6960              LDR      r0,[r4,#0x14]
00002a  07c0              LSLS     r0,r0,#31
00002c  d1fc              BNE      |L9.40|
;;;460        // clear RX buffer
;;;461        SPI_ClearRxFIFO(SPI_FLASH_PORT);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_ClearRxFIFO
;;;462    
;;;463        // read data
;;;464        if (EnablePDMA)
000034  b12e              CBZ      r6,|L9.66|
;;;465        {
;;;466    		SPI_Master_RX_PDMA(u8DataBuffer , SPI_FLASH_PAGE_BYTE);
000036  f44f7180          MOV      r1,#0x100
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SPI_Master_RX_PDMA
000040  e00a              B        |L9.88|
                  |L9.66|
;;;467        }
;;;468    	else
;;;469    	{
;;;470    	    for(i = 0 ; i < SPI_FLASH_PAGE_BYTE ; i++)
000042  2000              MOVS     r0,#0
000044  4603              MOV      r3,r0
                  |L9.70|
;;;471    	    {
;;;472    	        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
000046  6223              STR      r3,[r4,#0x20]
                  |L9.72|
;;;473    	        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000048  6962              LDR      r2,[r4,#0x14]
00004a  07d1              LSLS     r1,r2,#31
00004c  d1fc              BNE      |L9.72|
;;;474    	        u8DataBuffer[i] = SPI_READ_RX(SPI_FLASH_PORT);
00004e  6b21              LDR      r1,[r4,#0x30]
000050  5429              STRB     r1,[r5,r0]
000052  1c40              ADDS     r0,r0,#1
000054  28ff              CMP      r0,#0xff              ;470
000056  d9f6              BLS      |L9.70|
                  |L9.88|
;;;475    	    }
;;;476    	}
;;;477    
;;;478        // wait tx finish
;;;479        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000058  6960              LDR      r0,[r4,#0x14]
00005a  07c0              LSLS     r0,r0,#31
00005c  d1fc              BNE      |L9.88|
;;;480    
;;;481        // /CS: de-active
;;;482        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
00005e  68a0              LDR      r0,[r4,#8]
000060  f0200008          BIC      r0,r0,#8
000064  f0400005          ORR      r0,r0,#5
000068  60a0              STR      r0,[r4,#8]
;;;483    }
00006a  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

                  |L9.108|
                          DCD      0x40061000

                          AREA ||i.SpiFlash_PageRead||, CODE, READONLY, ALIGN=1

                  SpiFlash_PageRead PROC
;;;484    
;;;485    void SpiFlash_PageRead(uint32_t page_no, uint8_t *u8DataBuffer , uint8_t EnablePDMA)
000000  0200              LSLS     r0,r0,#8
;;;486    {
;;;487    	SpiFlash_NormalRead(page_no*SPI_FLASH_PAGE_BYTE , u8DataBuffer , EnablePDMA);
000002  f7ffbffe          B.W      SpiFlash_NormalRead
;;;488    }
;;;489    
                          ENDP


                          AREA ||i.SpiFlash_PageWrite||, CODE, READONLY, ALIGN=1

                  SpiFlash_PageWrite PROC
;;;437    
;;;438    void SpiFlash_PageWrite(uint32_t page_no, uint8_t *u8DataBuffer , uint8_t EnablePDMA)
000000  b510              PUSH     {r4,lr}
;;;439    {
;;;440    	SpiFlash_NormalPageProgram(page_no*SPI_FLASH_PAGE_BYTE , u8DataBuffer , EnablePDMA);
000002  0200              LSLS     r0,r0,#8
000004  f7fffffe          BL       SpiFlash_NormalPageProgram
;;;441    	SpiFlash_WaitReady();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      SpiFlash_WaitReady
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.SpiFlash_ReadMidDid||, CODE, READONLY, ALIGN=2

                  SpiFlash_ReadMidDid PROC
;;;240    
;;;241    uint16_t SpiFlash_ReadMidDid(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;242    {
;;;243        uint8_t u8RxData[6], u8IDCnt = 0;
;;;244    
;;;245        // /CS: active
;;;246        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  4912              LDR      r1,|L12.76|
000004  2000              MOVS     r0,#0                 ;243
000006  688a              LDR      r2,[r1,#8]
000008  f022020c          BIC      r2,r2,#0xc
00000c  f0420201          ORR      r2,r2,#1
000010  608a              STR      r2,[r1,#8]
;;;247    
;;;248        // send Command: 0x90, Read Manufacturer/Device ID
;;;249        SPI_WRITE_TX(SPI_FLASH_PORT, 0x90);
000012  2290              MOVS     r2,#0x90
000014  620a              STR      r2,[r1,#0x20]
;;;250    
;;;251        // send 24-bit '0', dummy
;;;252        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
000016  6208              STR      r0,[r1,#0x20]
;;;253        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
000018  6208              STR      r0,[r1,#0x20]
;;;254        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
00001a  6208              STR      r0,[r1,#0x20]
;;;255    
;;;256        // receive 16-bit
;;;257        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
00001c  6208              STR      r0,[r1,#0x20]
;;;258        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
00001e  6208              STR      r0,[r1,#0x20]
                  |L12.32|
;;;259    
;;;260        // wait tx finish
;;;261        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000020  694a              LDR      r2,[r1,#0x14]
000022  07d2              LSLS     r2,r2,#31
000024  d1fc              BNE      |L12.32|
;;;262    
;;;263        // /CS: de-active
;;;264        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
000026  688a              LDR      r2,[r1,#8]
000028  f0220208          BIC      r2,r2,#8
00002c  f0420205          ORR      r2,r2,#5
000030  608a              STR      r2,[r1,#8]
000032  466b              MOV      r3,sp                 ;243
;;;265    
;;;266        while(!SPI_GET_RX_FIFO_EMPTY_FLAG(SPI_FLASH_PORT))
000034  e003              B        |L12.62|
                  |L12.54|
;;;267            u8RxData[u8IDCnt ++] = SPI_READ_RX(SPI_FLASH_PORT);
000036  6b0a              LDR      r2,[r1,#0x30]
000038  541a              STRB     r2,[r3,r0]
00003a  1c40              ADDS     r0,r0,#1
00003c  b2c0              UXTB     r0,r0
                  |L12.62|
00003e  694a              LDR      r2,[r1,#0x14]         ;266
000040  05d2              LSLS     r2,r2,#23             ;266
000042  d5f8              BPL      |L12.54|
;;;268    
;;;269        return ( (u8RxData[4]<<8) | u8RxData[5] );
000044  f8bd0004          LDRH     r0,[sp,#4]
000048  ba40              REV16    r0,r0
;;;270    }
00004a  bd0c              POP      {r2,r3,pc}
;;;271    
                          ENDP

                  |L12.76|
                          DCD      0x40061000

                          AREA ||i.SpiFlash_ReadStatusReg||, CODE, READONLY, ALIGN=2

                  SpiFlash_ReadStatusReg PROC
;;;302    
;;;303    uint8_t SpiFlash_ReadStatusReg(void)
000000  480b              LDR      r0,|L13.48|
;;;304    {
;;;305        // /CS: active
;;;306        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  6881              LDR      r1,[r0,#8]
000004  f021010c          BIC      r1,r1,#0xc
000008  f0410101          ORR      r1,r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;307    
;;;308        // send Command: 0x05, Read status register
;;;309        SPI_WRITE_TX(SPI_FLASH_PORT, 0x05);
00000e  2105              MOVS     r1,#5
000010  6201              STR      r1,[r0,#0x20]
;;;310    
;;;311        // read status
;;;312        SPI_WRITE_TX(SPI_FLASH_PORT, 0x00);
000012  2100              MOVS     r1,#0
000014  6201              STR      r1,[r0,#0x20]
                  |L13.22|
;;;313    
;;;314        // wait tx finish
;;;315        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000016  6941              LDR      r1,[r0,#0x14]
000018  07c9              LSLS     r1,r1,#31
00001a  d1fc              BNE      |L13.22|
;;;316    
;;;317        // /CS: de-active
;;;318        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
00001c  6881              LDR      r1,[r0,#8]
00001e  f0210108          BIC      r1,r1,#8
000022  f0410105          ORR      r1,r1,#5
000026  6081              STR      r1,[r0,#8]
;;;319    
;;;320        // skip first rx data
;;;321        SPI_READ_RX(SPI_FLASH_PORT);
000028  6b01              LDR      r1,[r0,#0x30]
;;;322    
;;;323        return (SPI_READ_RX(SPI_FLASH_PORT) & 0xff);
00002a  6b00              LDR      r0,[r0,#0x30]
00002c  b2c0              UXTB     r0,r0
;;;324    }
00002e  4770              BX       lr
;;;325    
                          ENDP

                  |L13.48|
                          DCD      0x40061000

                          AREA ||i.SpiFlash_WaitReady||, CODE, READONLY, ALIGN=2

                  SpiFlash_WaitReady PROC
;;;357    
;;;358    void SpiFlash_WaitReady(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360        uint8_t ReturnValue = 0;
;;;361    //    uint32_t cnt = 0;
;;;362    	
;;;363        do
;;;364        {
;;;365            ReturnValue = SpiFlash_ReadStatusReg();
;;;366            ReturnValue = ReturnValue & 1;
;;;367    
;;;368    		#if 1	//debug purpose
;;;369    //		printf("BUSY counter : %4d\r\n" , cnt++);
;;;370    //		printf(".");
;;;371    		LED_Y ^= 1;
000002  4a07              LDR      r2,|L14.32|
                  |L14.4|
000004  f7fffffe          BL       SpiFlash_ReadStatusReg
000008  6811              LDR      r1,[r2,#0]
00000a  f0100f01          TST      r0,#1                 ;366
00000e  f0810101          EOR      r1,r1,#1
000012  6011              STR      r1,[r2,#0]
;;;372    		
;;;373    		#endif
;;;374    
;;;375        }
;;;376        while(ReturnValue!=0);   // check the BUSY bit
000014  d1f6              BNE      |L14.4|
;;;377    
;;;378    	printf("\r\n");
000016  e8bd4010          POP      {r4,lr}
00001a  a002              ADR      r0,|L14.36|
00001c  f7ffbffe          B.W      __2printf
;;;379    }
;;;380    
                          ENDP

                  |L14.32|
                          DCD      0x400049c4
                  |L14.36|
000024  0d0a00            DCB      "\r\n",0
000027  00                DCB      0

                          AREA ||i.SpiFlash_WriteStatusReg||, CODE, READONLY, ALIGN=2

                  SpiFlash_WriteStatusReg PROC
;;;325    
;;;326    void SpiFlash_WriteStatusReg(uint8_t u8Value)
000000  4912              LDR      r1,|L15.76|
;;;327    {
;;;328        // /CS: active
;;;329        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000002  688a              LDR      r2,[r1,#8]
000004  f022020c          BIC      r2,r2,#0xc
000008  f0420201          ORR      r2,r2,#1
00000c  608a              STR      r2,[r1,#8]
;;;330    
;;;331        // send Command: 0x06, Write enable
;;;332        SPI_WRITE_TX(SPI_FLASH_PORT, 0x06);
00000e  2206              MOVS     r2,#6
000010  620a              STR      r2,[r1,#0x20]
                  |L15.18|
;;;333    
;;;334        // wait tx finish
;;;335        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000012  694a              LDR      r2,[r1,#0x14]
000014  07d2              LSLS     r2,r2,#31
000016  d1fc              BNE      |L15.18|
;;;336    
;;;337        // /CS: de-active
;;;338        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
000018  688a              LDR      r2,[r1,#8]
00001a  f0220208          BIC      r2,r2,#8
00001e  f0420205          ORR      r2,r2,#5
000022  608a              STR      r2,[r1,#8]
;;;339    
;;;340        ///////////////////////////////////////
;;;341    
;;;342        // /CS: active
;;;343        SPI_SET_SS_LOW(SPI_FLASH_PORT);
000024  688a              LDR      r2,[r1,#8]
000026  f022020c          BIC      r2,r2,#0xc
00002a  f0420201          ORR      r2,r2,#1
00002e  608a              STR      r2,[r1,#8]
;;;344    
;;;345        // send Command: 0x01, Write status register
;;;346        SPI_WRITE_TX(SPI_FLASH_PORT, 0x01);
000030  2201              MOVS     r2,#1
000032  620a              STR      r2,[r1,#0x20]
;;;347    
;;;348        // write status
;;;349        SPI_WRITE_TX(SPI_FLASH_PORT, u8Value);
000034  6208              STR      r0,[r1,#0x20]
                  |L15.54|
;;;350    
;;;351        // wait tx finish
;;;352        while(SPI_IS_BUSY(SPI_FLASH_PORT));
000036  6948              LDR      r0,[r1,#0x14]
000038  07c0              LSLS     r0,r0,#31
00003a  d1fc              BNE      |L15.54|
;;;353    
;;;354        // /CS: de-active
;;;355        SPI_SET_SS_HIGH(SPI_FLASH_PORT);
00003c  6888              LDR      r0,[r1,#8]
00003e  f0200008          BIC      r0,r0,#8
000042  f0400005          ORR      r0,r0,#5
000046  6088              STR      r0,[r1,#8]
;;;356    }
000048  4770              BX       lr
;;;357    
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      0x40061000

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;800    
;;;801    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;802    {
;;;803    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L16.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;804    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;805    }
;;;806    
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;806    
;;;807    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;808    {
;;;809    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L17.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;810    }
;;;811    
                          ENDP

                  |L17.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;786    
;;;787    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;788    {
;;;789        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L18.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;790        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;791    }
;;;792    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;792    
;;;793    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;794    {
;;;795        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L19.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;796        TIMER_EnableInt(TIMER1);
;;;797        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;798        TIMER_Start(TIMER1);
;;;799    }
000028  bd10              POP      {r4,pc}
;;;800    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;767    
;;;768    void TMR1_IRQHandler(void)
000000  480b              LDR      r0,|L20.48|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;769    {
000008  2900              CMP      r1,#0
00000a  d00f              BEQ      |L20.44|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;770    	static uint16_t CNT = 0;	
;;;771    //	static uint32_t log = 0;	
;;;772    	
;;;773        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;774        {
;;;775            TIMER_ClearIntFlag(TIMER1);
;;;776    	
;;;777    		if (CNT++ > 1000)
000010  4908              LDR      r1,|L20.52|
000012  8848              LDRH     r0,[r1,#2]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  804a              STRH     r2,[r1,#2]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d906              BLS      |L20.44|
;;;778    		{		
;;;779    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8048              STRH     r0,[r1,#2]
;;;780    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;781    
;;;782    			LED_G ^= 1;
000022  4805              LDR      r0,|L20.56|
000024  6801              LDR      r1,[r0,#0]
000026  f0810101          EOR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L20.44|
;;;783    		}
;;;784        }
;;;785    }
00002c  4770              BX       lr
;;;786    
                          ENDP

00002e  0000              DCW      0x0000
                  |L20.48|
                          DCD      0x40050100
                  |L20.52|
                          DCD      ||.data||
                  |L20.56|
                          DCD      0x400049c8

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;725    
;;;726    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;727    {
;;;728        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L21.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L21.18|
00000c  e004              B        |L21.24|
                  |L21.14|
;;;729        {
;;;730            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;731            {
;;;732    //			set_flag(flag_uart_rx,ENABLE);
;;;733    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L21.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;730
000014  0449              LSLS     r1,r1,#17             ;730
000016  d5fa              BPL      |L21.14|
                  |L21.24|
;;;734            }
;;;735        }
;;;736    
;;;737        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L21.46|
;;;738        {
;;;739            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L21.46|
;;;740        }
;;;741    }
00002e  bd10              POP      {r4,pc}
;;;742    
                          ENDP

                  |L21.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;742    
;;;743    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;744    {
;;;745        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L22.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;746    
;;;747        /* Configure UART0 and set UART0 baud rate */
;;;748        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L22.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;749    
;;;750    	/* Set UART receive time-out */
;;;751    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;752    
;;;753    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;754    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;755    
;;;756    	/* Enable UART Interrupt - */
;;;757    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;758    	
;;;759    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;760    
;;;761    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L22.132|
000044  f7fffffe          BL       __2printf
;;;762    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L22.160|
000050  f7fffffe          BL       __2printf
;;;763    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L22.184|
00005c  f7fffffe          BL       __2printf
;;;764    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L22.208|
000068  f7fffffe          BL       __2printf
;;;765    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L22.236|
000078  f7ffbffe          B.W      __2printf
;;;766    }
;;;767    
                          ENDP

                  |L22.124|
                          DCD      0x04000010
                  |L22.128|
                          DCD      0x40070000
                  |L22.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L22.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L22.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L22.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L22.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UARTx_Process PROC
;;;529    
;;;530    void UARTx_Process(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;531    {
;;;532    	uint8_t res = 0;
;;;533        uint16_t i = 0;
;;;534    	static uint8_t cnt = 0;
;;;535        uint16_t page_cnt = 0;
;;;536    	
;;;537    	res = UART_READ(UART0);
000004  4888              LDR      r0,|L23.552|
000006  2500              MOVS     r5,#0                 ;533
000008  462c              MOV      r4,r5                 ;535
00000a  6800              LDR      r0,[r0,#0]
00000c  b2c0              UXTB     r0,r0
;;;538    
;;;539    	if (res > 0x7F)
00000e  287f              CMP      r0,#0x7f
000010  d901              BLS      |L23.22|
;;;540    	{
;;;541    		printf("invalid command\r\n");
000012  a086              ADR      r0,|L23.556|
000014  e0fc              B        |L23.528|
                  |L23.22|
;;;542    	}
;;;543    	else
;;;544    	{
;;;545    		switch(res)
;;;546    		{
;;;547    			case '?':
;;;548    
;;;549    				printf("\r\n==========================\r\n");
;;;550    				
;;;551    				printf("1: chip erase\r\n");
;;;552    				printf("2: fill in TX data\r\n");
;;;553    				printf("3: page counter\r\n");
;;;554    				printf("4: Page write\r\n");
;;;555    				printf("5: Page read\r\n");		
;;;556    				printf("6: self test , write , read , compare\r\n");	
;;;557    				printf("7: self test , write , read , compare  , with PDMA\r\n");
;;;558    				
;;;559    				printf("8: read ID (0x90)\r\n");	
;;;560    				
;;;561    				printf("==========================\r\n\r\n");
;;;562    				break;	
;;;563    
;;;564    		
;;;565    			case '1':
;;;566    				printf("perform SpiFlash_ChipErase\r\n");
;;;567    				
;;;568    			    /* Erase SPI flash */
;;;569    			    SpiFlash_ChipErase();
;;;570    
;;;571    			    /* Wait ready */
;;;572    			    SpiFlash_WaitReady();
;;;573    
;;;574    				printf("erase finish\r\n\r\n");
;;;575    				break;	
;;;576    
;;;577    			case '2':
;;;578    				printf("increase test data start from 0x%2X\r\n" , cnt);
;;;579    
;;;580    				//reset TxBuffer
;;;581    				reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
000016  f8df8228          LDR      r8,|L23.576|
00001a  4e8a              LDR      r6,|L23.580|
00001c  f44f7780          MOV      r7,#0x100
000020  2837              CMP      r0,#0x37              ;545
000022  d075              BEQ      |L23.272|
000024  dc08              BGT      |L23.56|
000026  f1a00031          SUB      r0,r0,#0x31           ;545
00002a  2806              CMP      r0,#6                 ;545
00002c  d25f              BCS      |L23.238|
00002e  e8dff000          TBB      [pc,r0]               ;545
000032  3b44              DCB      0x3b,0x44
000034  60657183          DCB      0x60,0x65,0x71,0x83
                  |L23.56|
000038  285a              CMP      r0,#0x5a              ;545
00003a  d00b              BEQ      |L23.84|
00003c  dc06              BGT      |L23.76|
00003e  2838              CMP      r0,#0x38              ;545
000040  d067              BEQ      |L23.274|
000042  283f              CMP      r0,#0x3f              ;545
000044  d013              BEQ      |L23.110|
000046  2858              CMP      r0,#0x58              ;545
000048  d151              BNE      |L23.238|
00004a  e003              B        |L23.84|
                  |L23.76|
00004c  2878              CMP      r0,#0x78              ;545
00004e  d001              BEQ      |L23.84|
000050  287a              CMP      r0,#0x7a              ;545
000052  d14c              BNE      |L23.238|
                  |L23.84|
000054  f3bf8f4f          DSB                            ;545
000058  497b              LDR      r1,|L23.584|
00005a  6808              LDR      r0,[r1,#0]            ;545
00005c  4a7b              LDR      r2,|L23.588|
00005e  f40060e0          AND      r0,r0,#0x700          ;545
000062  4310              ORRS     r0,r0,r2              ;545
000064  6008              STR      r0,[r1,#0]            ;545
000066  f3bf8f4f          DSB                            ;545
                  |L23.106|
00006a  bf00              NOP                            ;545
00006c  e7fd              B        |L23.106|
                  |L23.110|
00006e  a078              ADR      r0,|L23.592|
000070  f7fffffe          BL       __2printf
000074  a07e              ADR      r0,|L23.624|
000076  f7fffffe          BL       __2printf
00007a  a081              ADR      r0,|L23.640|
00007c  f7fffffe          BL       __2printf
000080  a085              ADR      r0,|L23.664|
000082  f7fffffe          BL       __2printf
000086  a089              ADR      r0,|L23.684|
000088  f7fffffe          BL       __2printf
00008c  a08b              ADR      r0,|L23.700|
00008e  f7fffffe          BL       __2printf
000092  a08e              ADR      r0,|L23.716|
000094  f7fffffe          BL       __2printf
000098  a096              ADR      r0,|L23.756|
00009a  f7fffffe          BL       __2printf
00009e  a0a3              ADR      r0,|L23.812|
0000a0  f7fffffe          BL       __2printf
0000a4  a0a6              ADR      r0,|L23.832|
0000a6  e0b3              B        |L23.528|
0000a8  a0ad              ADR      r0,|L23.864|
0000aa  f7fffffe          BL       __2printf
0000ae  f7fffffe          BL       SpiFlash_ChipErase
0000b2  f7fffffe          BL       SpiFlash_WaitReady
0000b6  a0b2              ADR      r0,|L23.896|
0000b8  e0aa              B        |L23.528|
0000ba  7871              LDRB     r1,[r6,#1]            ;578  ; cnt
0000bc  a0b5              ADR      r0,|L23.916|
0000be  f7fffffe          BL       __2printf
0000c2  4639              MOV      r1,r7
0000c4  485e              LDR      r0,|L23.576|
0000c6  f7fffffe          BL       reset_buffer
0000ca  7872              LDRB     r2,[r6,#1]            ;578
0000cc  4641              MOV      r1,r8
                  |L23.206|
;;;582    
;;;583    				//fill in data
;;;584    			    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;585    			    {
;;;586    			        TxBuffer[i] = 0x00 + i + cnt;
0000ce  18a8              ADDS     r0,r5,r2
0000d0  5548              STRB     r0,[r1,r5]
0000d2  1c6d              ADDS     r5,r5,#1
0000d4  b2ad              UXTH     r5,r5                 ;584
0000d6  2dff              CMP      r5,#0xff              ;584
0000d8  d9f9              BLS      |L23.206|
;;;587    			    }
;;;588    
;;;589    				printf("TxBuffer : \r\n");
0000da  a0b8              ADR      r0,|L23.956|
0000dc  f7fffffe          BL       __2printf
;;;590    				dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
0000e0  4639              MOV      r1,r7
0000e2  4857              LDR      r0,|L23.576|
0000e4  f7fffffe          BL       dump_buffer_hex
;;;591    				cnt++; 
0000e8  7870              LDRB     r0,[r6,#1]  ; cnt
0000ea  1c40              ADDS     r0,r0,#1
0000ec  7070              STRB     r0,[r6,#1]
                  |L23.238|
;;;592    			
;;;593    				break;
;;;594    
;;;595    			case '3':
;;;596    				printf("SPI_FLASH_page_counter current : 0x%2X\r\n\r\n" ,SPI_FLASH_page_counter++);	
;;;597    			
;;;598    				break;
;;;599    
;;;600    			case '4':
;;;601    				printf("programming...\r\n");
;;;602    				SpiFlash_PageWrite(SPI_FLASH_page_counter,TxBuffer,DISABLE);
;;;603    				printf("programming finish\r\n\r\n");
;;;604    				
;;;605    				break;
;;;606    
;;;607    			case '5':
;;;608    				//reset RxBuffer
;;;609    			    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;610    
;;;611    				printf("read page ...\r\n");
;;;612    				SpiFlash_PageRead(SPI_FLASH_page_counter,RxBuffer,DISABLE);
;;;613    				dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;614    				printf("read page finish\r\n\r\n");	
;;;615    				
;;;616    				break;				
;;;617    
;;;618    			case '6':
;;;619    				//reset RxBuffer
;;;620    			    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;621    
;;;622    				printf("perform SpiFlash_ChipErase\r\n");
;;;623    				
;;;624    			    /* Erase SPI flash */
;;;625    			    SpiFlash_ChipErase();
;;;626    
;;;627    			    /* Wait ready */
;;;628    			    SpiFlash_WaitReady();
;;;629    
;;;630    				printf("erase finish\r\n\r\n");
;;;631    
;;;632    				for ( page_cnt = 0 ; page_cnt < TEST_NUMBER ; page_cnt++)
;;;633    				{
;;;634    					printf("\r\nSELF TEST ... (page : %2d)\r\n" , page_cnt);
;;;635    
;;;636    					//reset TxBuffer
;;;637    					reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
;;;638    
;;;639    					//fill in data
;;;640    				    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;641    				    {
;;;642    				        TxBuffer[i] = 0x00 + i + cnt;
;;;643    				    }
;;;644    
;;;645    //					printf("\r\nTxBuffer : \r\n");
;;;646    //					dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;647    					cnt++;
;;;648    					
;;;649    					SpiFlash_PageWrite(page_cnt,TxBuffer,DISABLE);
;;;650    					SpiFlash_PageRead(page_cnt,RxBuffer,DISABLE);
;;;651    
;;;652    //					printf("\r\nRxBuffer\r\n");
;;;653    //					dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);		
;;;654    
;;;655    					compare_buffer(TxBuffer,RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;656    				}
;;;657    
;;;658    				printf("SELF TEST finish\r\n\r\n");	
;;;659    			
;;;660    				break;	
;;;661    
;;;662    
;;;663    			case '7':
;;;664    
;;;665    				//reset RxBuffer
;;;666    			    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;667    
;;;668    				printf("perform SpiFlash_ChipErase\r\n");
;;;669    				
;;;670    			    /* Erase SPI flash */
;;;671    			    SpiFlash_ChipErase();
;;;672    
;;;673    			    /* Wait ready */
;;;674    			    SpiFlash_WaitReady();
;;;675    
;;;676    				printf("erase finish\r\n\r\n");
;;;677    
;;;678    				for ( page_cnt = 0 ; page_cnt < TEST_NUMBER ; page_cnt++)
;;;679    				{
;;;680    					printf("\r\nPDMA SELF TEST ... (page : %2d)\r\n" , page_cnt);
;;;681    
;;;682    					//reset TxBuffer
;;;683    					reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
;;;684    
;;;685    					//fill in data
;;;686    				    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;687    				    {
;;;688    				        TxBuffer[i] = 0x00 + i + cnt;
;;;689    				    }
;;;690    
;;;691    //					printf("\r\nTxBuffer : \r\n");
;;;692    //					dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;693    					cnt++;
;;;694    					
;;;695    					SpiFlash_PageWrite(page_cnt,TxBuffer,ENABLE);
;;;696    					SpiFlash_PageRead(page_cnt,RxBuffer,ENABLE);
;;;697    
;;;698    //					printf("\r\nRxBuffer\r\n");
;;;699    //					dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);		
;;;700    
;;;701    					compare_buffer(TxBuffer,RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;702    				}
;;;703    
;;;704    				printf("PDMA SELF TEST finish\r\n\r\n");	
;;;705    
;;;706    				break;
;;;707    
;;;708    			case '8':			
;;;709    				i = SpiFlash_ReadMidDid();
;;;710    				printf("SpiFlash_ReadMidDid : 0x%2X\r\n\n" , i);
;;;711    				
;;;712    				break;
;;;713    
;;;714    			case 'X':
;;;715    			case 'x':
;;;716    			case 'Z':
;;;717    			case 'z':
;;;718    				NVIC_SystemReset();
;;;719    			
;;;720    				break;		
;;;721    			
;;;722    		}
;;;723    	}
;;;724    }
0000ee  e8bd81f0          POP      {r4-r8,pc}
0000f2  7831              LDRB     r1,[r6,#0]            ;596  ; SPI_FLASH_page_counter
0000f4  1c48              ADDS     r0,r1,#1              ;596
0000f6  7030              STRB     r0,[r6,#0]            ;596
0000f8  a0b4              ADR      r0,|L23.972|
0000fa  e091              B        |L23.544|
0000fc  a0be              ADR      r0,|L23.1016|
0000fe  f7fffffe          BL       __2printf
000102  2200              MOVS     r2,#0                 ;602
000104  494e              LDR      r1,|L23.576|
000106  7830              LDRB     r0,[r6,#0]            ;602  ; SPI_FLASH_page_counter
000108  f7fffffe          BL       SpiFlash_PageWrite
00010c  a0bf              ADR      r0,|L23.1036|
00010e  e07f              B        |L23.528|
                  |L23.272|
000110  e049              B        |L23.422|
                  |L23.274|
000112  e081              B        |L23.536|
000114  4639              MOV      r1,r7                 ;609
000116  48c3              LDR      r0,|L23.1060|
000118  f7fffffe          BL       reset_buffer
00011c  a0c2              ADR      r0,|L23.1064|
00011e  f7fffffe          BL       __2printf
000122  2200              MOVS     r2,#0                 ;612
000124  49bf              LDR      r1,|L23.1060|
000126  7830              LDRB     r0,[r6,#0]            ;612  ; SPI_FLASH_page_counter
000128  f7fffffe          BL       SpiFlash_PageRead
00012c  4639              MOV      r1,r7                 ;613
00012e  48bd              LDR      r0,|L23.1060|
000130  f7fffffe          BL       dump_buffer_hex
000134  a0c0              ADR      r0,|L23.1080|
000136  e06b              B        |L23.528|
000138  463d              MOV      r5,r7                 ;620
00013a  4639              MOV      r1,r7                 ;620
00013c  48b9              LDR      r0,|L23.1060|
00013e  f7fffffe          BL       reset_buffer
000142  a087              ADR      r0,|L23.864|
000144  f7fffffe          BL       __2printf
000148  f7fffffe          BL       SpiFlash_ChipErase
00014c  f7fffffe          BL       SpiFlash_WaitReady
000150  a08b              ADR      r0,|L23.896|
000152  f7fffffe          BL       __2printf
000156  4647              MOV      r7,r8                 ;581
                  |L23.344|
000158  4621              MOV      r1,r4                 ;634
00015a  a0bd              ADR      r0,|L23.1104|
00015c  f7fffffe          BL       __2printf
000160  4629              MOV      r1,r5                 ;637
000162  4837              LDR      r0,|L23.576|
000164  f7fffffe          BL       reset_buffer
000168  7871              LDRB     r1,[r6,#1]            ;578
00016a  2000              MOVS     r0,#0                 ;640
                  |L23.364|
00016c  1842              ADDS     r2,r0,r1              ;642
00016e  543a              STRB     r2,[r7,r0]            ;642
000170  1c40              ADDS     r0,r0,#1              ;642
000172  b280              UXTH     r0,r0                 ;640
000174  28ff              CMP      r0,#0xff              ;640
000176  d9f9              BLS      |L23.364|
000178  1c49              ADDS     r1,r1,#1              ;640
00017a  7071              STRB     r1,[r6,#1]            ;647
00017c  2200              MOVS     r2,#0                 ;649
00017e  4930              LDR      r1,|L23.576|
000180  4620              MOV      r0,r4                 ;649
000182  f7fffffe          BL       SpiFlash_PageWrite
000186  2200              MOVS     r2,#0                 ;650
000188  49a6              LDR      r1,|L23.1060|
00018a  4620              MOV      r0,r4                 ;650
00018c  f7fffffe          BL       SpiFlash_PageRead
000190  462a              MOV      r2,r5                 ;655
000192  49a4              LDR      r1,|L23.1060|
000194  482a              LDR      r0,|L23.576|
000196  f7fffffe          BL       compare_buffer
00019a  1c64              ADDS     r4,r4,#1              ;655
00019c  b2a4              UXTH     r4,r4                 ;632
00019e  2c10              CMP      r4,#0x10              ;632
0001a0  d3da              BCC      |L23.344|
0001a2  a0b3              ADR      r0,|L23.1136|
0001a4  e034              B        |L23.528|
                  |L23.422|
0001a6  4639              MOV      r1,r7                 ;666
0001a8  489e              LDR      r0,|L23.1060|
0001aa  f7fffffe          BL       reset_buffer
0001ae  a06c              ADR      r0,|L23.864|
0001b0  f7fffffe          BL       __2printf
0001b4  f7fffffe          BL       SpiFlash_ChipErase
0001b8  f7fffffe          BL       SpiFlash_WaitReady
0001bc  a070              ADR      r0,|L23.896|
0001be  f7fffffe          BL       __2printf
0001c2  4645              MOV      r5,r8                 ;581
                  |L23.452|
0001c4  4621              MOV      r1,r4                 ;680
0001c6  a0b0              ADR      r0,|L23.1160|
0001c8  f7fffffe          BL       __2printf
0001cc  4639              MOV      r1,r7                 ;683
0001ce  481c              LDR      r0,|L23.576|
0001d0  f7fffffe          BL       reset_buffer
0001d4  7871              LDRB     r1,[r6,#1]            ;578
0001d6  2000              MOVS     r0,#0                 ;686
                  |L23.472|
0001d8  1842              ADDS     r2,r0,r1              ;688
0001da  542a              STRB     r2,[r5,r0]            ;688
0001dc  1c40              ADDS     r0,r0,#1              ;688
0001de  b280              UXTH     r0,r0                 ;686
0001e0  28ff              CMP      r0,#0xff              ;686
0001e2  d9f9              BLS      |L23.472|
0001e4  1c49              ADDS     r1,r1,#1              ;686
0001e6  7071              STRB     r1,[r6,#1]            ;693
0001e8  2201              MOVS     r2,#1                 ;695
0001ea  4915              LDR      r1,|L23.576|
0001ec  4620              MOV      r0,r4                 ;695
0001ee  f7fffffe          BL       SpiFlash_PageWrite
0001f2  2201              MOVS     r2,#1                 ;696
0001f4  498b              LDR      r1,|L23.1060|
0001f6  4620              MOV      r0,r4                 ;696
0001f8  f7fffffe          BL       SpiFlash_PageRead
0001fc  463a              MOV      r2,r7                 ;701
0001fe  4989              LDR      r1,|L23.1060|
000200  480f              LDR      r0,|L23.576|
000202  f7fffffe          BL       compare_buffer
000206  1c64              ADDS     r4,r4,#1              ;701
000208  b2a4              UXTH     r4,r4                 ;678
00020a  2c10              CMP      r4,#0x10              ;678
00020c  d3da              BCC      |L23.452|
00020e  a0a7              ADR      r0,|L23.1196|
                  |L23.528|
000210  e8bd41f0          POP      {r4-r8,lr}            ;704
000214  f7ffbffe          B.W      __2printf
                  |L23.536|
000218  f7fffffe          BL       SpiFlash_ReadMidDid
00021c  4601              MOV      r1,r0                 ;709
00021e  a0aa              ADR      r0,|L23.1224|
                  |L23.544|
000220  e8bd41f0          POP      {r4-r8,lr}            ;710
000224  f7ffbffe          B.W      __2printf
;;;725    
                          ENDP

                  |L23.552|
                          DCD      0x40070000
                  |L23.556|
00022c  696e7661          DCB      "invalid command\r\n",0
000230  6c696420
000234  636f6d6d
000238  616e640d
00023c  0a00    
00023e  00                DCB      0
00023f  00                DCB      0
                  |L23.576|
                          DCD      ||.bss||
                  |L23.580|
                          DCD      ||.data||
                  |L23.584|
                          DCD      0xe000ed0c
                  |L23.588|
                          DCD      0x05fa0004
                  |L23.592|
000250  0d0a3d3d          DCB      "\r\n==========================\r\n",0
000254  3d3d3d3d
000258  3d3d3d3d
00025c  3d3d3d3d
000260  3d3d3d3d
000264  3d3d3d3d
000268  3d3d3d3d
00026c  0d0a00  
00026f  00                DCB      0
                  |L23.624|
000270  313a2063          DCB      "1: chip erase\r\n",0
000274  68697020
000278  65726173
00027c  650d0a00
                  |L23.640|
000280  323a2066          DCB      "2: fill in TX data\r\n",0
000284  696c6c20
000288  696e2054
00028c  58206461
000290  74610d0a
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0
                  |L23.664|
000298  333a2070          DCB      "3: page counter\r\n",0
00029c  61676520
0002a0  636f756e
0002a4  7465720d
0002a8  0a00    
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L23.684|
0002ac  343a2050          DCB      "4: Page write\r\n",0
0002b0  61676520
0002b4  77726974
0002b8  650d0a00
                  |L23.700|
0002bc  353a2050          DCB      "5: Page read\r\n",0
0002c0  61676520
0002c4  72656164
0002c8  0d0a00  
0002cb  00                DCB      0
                  |L23.716|
0002cc  363a2073          DCB      "6: self test , write , read , compare\r\n",0
0002d0  656c6620
0002d4  74657374
0002d8  202c2077
0002dc  72697465
0002e0  202c2072
0002e4  65616420
0002e8  2c20636f
0002ec  6d706172
0002f0  650d0a00
                  |L23.756|
0002f4  373a2073          DCB      "7: self test , write , read , compare  , with PDMA\r\n",0
0002f8  656c6620
0002fc  74657374
000300  202c2077
000304  72697465
000308  202c2072
00030c  65616420
000310  2c20636f
000314  6d706172
000318  6520202c
00031c  20776974
000320  68205044
000324  4d410d0a
000328  00      
000329  00                DCB      0
00032a  00                DCB      0
00032b  00                DCB      0
                  |L23.812|
00032c  383a2072          DCB      "8: read ID (0x90)\r\n",0
000330  65616420
000334  49442028
000338  30783930
00033c  290d0a00
                  |L23.832|
000340  3d3d3d3d          DCB      "==========================\r\n\r\n",0
000344  3d3d3d3d
000348  3d3d3d3d
00034c  3d3d3d3d
000350  3d3d3d3d
000354  3d3d3d3d
000358  3d3d0d0a
00035c  0d0a00  
00035f  00                DCB      0
                  |L23.864|
000360  70657266          DCB      "perform SpiFlash_ChipErase\r\n",0
000364  6f726d20
000368  53706946
00036c  6c617368
000370  5f436869
000374  70457261
000378  73650d0a
00037c  00      
00037d  00                DCB      0
00037e  00                DCB      0
00037f  00                DCB      0
                  |L23.896|
000380  65726173          DCB      "erase finish\r\n\r\n",0
000384  65206669
000388  6e697368
00038c  0d0a0d0a
000390  00      
000391  00                DCB      0
000392  00                DCB      0
000393  00                DCB      0
                  |L23.916|
000394  696e6372          DCB      "increase test data start from 0x%2X\r\n",0
000398  65617365
00039c  20746573
0003a0  74206461
0003a4  74612073
0003a8  74617274
0003ac  2066726f
0003b0  6d203078
0003b4  2532580d
0003b8  0a00    
0003ba  00                DCB      0
0003bb  00                DCB      0
                  |L23.956|
0003bc  54784275          DCB      "TxBuffer : \r\n",0
0003c0  66666572
0003c4  203a200d
0003c8  0a00    
0003ca  00                DCB      0
0003cb  00                DCB      0
                  |L23.972|
0003cc  5350495f          DCB      "SPI_FLASH_page_counter current : 0x%2X\r\n\r\n",0
0003d0  464c4153
0003d4  485f7061
0003d8  67655f63
0003dc  6f756e74
0003e0  65722063
0003e4  75727265
0003e8  6e74203a
0003ec  20307825
0003f0  32580d0a
0003f4  0d0a00  
0003f7  00                DCB      0
                  |L23.1016|
0003f8  70726f67          DCB      "programming...\r\n",0
0003fc  72616d6d
000400  696e672e
000404  2e2e0d0a
000408  00      
000409  00                DCB      0
00040a  00                DCB      0
00040b  00                DCB      0
                  |L23.1036|
00040c  70726f67          DCB      "programming finish\r\n\r\n",0
000410  72616d6d
000414  696e6720
000418  66696e69
00041c  73680d0a
000420  0d0a00  
000423  00                DCB      0
                  |L23.1060|
                          DCD      ||.bss||+0x100
                  |L23.1064|
000428  72656164          DCB      "read page ...\r\n",0
00042c  20706167
000430  65202e2e
000434  2e0d0a00
                  |L23.1080|
000438  72656164          DCB      "read page finish\r\n\r\n",0
00043c  20706167
000440  65206669
000444  6e697368
000448  0d0a0d0a
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L23.1104|
000450  0d0a5345          DCB      "\r\nSELF TEST ... (page : %2d)\r\n",0
000454  4c462054
000458  45535420
00045c  2e2e2e20
000460  28706167
000464  65203a20
000468  25326429
00046c  0d0a00  
00046f  00                DCB      0
                  |L23.1136|
000470  53454c46          DCB      "SELF TEST finish\r\n\r\n",0
000474  20544553
000478  54206669
00047c  6e697368
000480  0d0a0d0a
000484  00      
000485  00                DCB      0
000486  00                DCB      0
000487  00                DCB      0
                  |L23.1160|
000488  0d0a5044          DCB      "\r\nPDMA SELF TEST ... (page : %2d)\r\n",0
00048c  4d412053
000490  454c4620
000494  54455354
000498  202e2e2e
00049c  20287061
0004a0  6765203a
0004a4  20253264
0004a8  290d0a00
                  |L23.1196|
0004ac  50444d41          DCB      "PDMA SELF TEST finish\r\n\r\n",0
0004b0  2053454c
0004b4  46205445
0004b8  53542066
0004bc  696e6973
0004c0  680d0a0d
0004c4  0a00    
0004c6  00                DCB      0
0004c7  00                DCB      0
                  |L23.1224|
0004c8  53706946          DCB      "SpiFlash_ReadMidDid : 0x%2X\r\n\n",0
0004cc  6c617368
0004d0  5f526561
0004d4  644d6964
0004d8  44696420
0004dc  3a203078
0004e0  2532580d
0004e4  0a0a00  
0004e7  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;63     
;;;64     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65     {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;66         uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;67     	
;;;68         for (i = 0; i < nBytes; i++)
;;;69         {
;;;70             if (src[i] != des[i])
;;;71             {
;;;72                 printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;73     			set_flag(flag_error , ENABLE);
00000c  4d0f              LDR      r5,|L24.76|
00000e  e00e              B        |L24.46|
                  |L24.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;70
000014  5d3b              LDRB     r3,[r7,r4]            ;70
000016  429a              CMP      r2,r3                 ;70
000018  d007              BEQ      |L24.42|
00001a  4621              MOV      r1,r4                 ;72
00001c  a00c              ADR      r0,|L24.80|
00001e  f7fffffe          BL       __2printf
000022  6868              LDR      r0,[r5,#4]  ; BitFlag
000024  f0400002          ORR      r0,r0,#2
000028  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L24.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;68
                  |L24.46|
00002e  42b4              CMP      r4,r6                 ;68
000030  dbee              BLT      |L24.16|
;;;74             }
;;;75         }
;;;76     
;;;77     	if (!is_flag_set(flag_error))
000032  7928              LDRB     r0,[r5,#4]  ; BitFlag
000034  0780              LSLS     r0,r0,#30
000036  d407              BMI      |L24.72|
;;;78     	{
;;;79         	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L24.116|
00003a  a00f              ADR      r0,|L24.120|
00003c  f7fffffe          BL       __2printf
;;;80     		set_flag(flag_error , DISABLE);
000040  6868              LDR      r0,[r5,#4]  ; BitFlag
000042  f0200002          BIC      r0,r0,#2
000046  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L24.72|
;;;81     	}
;;;82     
;;;83     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;84     
                          ENDP

                  |L24.76|
                          DCD      ||.data||
                  |L24.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L24.116|
                          DCD      ||.constdata||
                  |L24.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;97     
;;;98     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;100        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;101        
;;;102        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L25.56|
00000a  f7fffffe          BL       __2printf
;;;103        for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L25.42|
                  |L25.16|
;;;104        {
;;;105            printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L25.76|
000014  f7fffffe          BL       __2printf
;;;106            if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L25.38|
;;;107            {
;;;108                printf("\r\n");
000020  a00c              ADR      r0,|L25.84|
000022  f7fffffe          BL       __2printf
                  |L25.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;103
                  |L25.42|
00002a  42ac              CMP      r4,r5                 ;103
00002c  dbf0              BLT      |L25.16|
;;;109            }            
;;;110        }
;;;111        printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L25.88|
000034  f7ffbffe          B.W      __2printf
;;;112    }
;;;113    
                          ENDP

                  |L25.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L25.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L25.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L25.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;113    
;;;114    void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;115    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;116        int     nIdx, i;
;;;117    
;;;118        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L26.88|
                  |L26.12|
;;;119        while (nBytes > 0)
;;;120        {
;;;121            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L26.104|
000010  f7fffffe          BL       __2printf
;;;122            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L26.22|
;;;123                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L26.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;122
000024  dbf7              BLT      |L26.22|
;;;124            printf("  ");
000026  a015              ADR      r0,|L26.124|
000028  f7fffffe          BL       __2printf
;;;125            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L26.46|
;;;126            {
;;;127                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L26.66|
;;;128                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L26.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L26.72|
                  |L26.66|
;;;129                else
;;;130                    printf(".");
000042  a010              ADR      r0,|L26.132|
000044  f7fffffe          BL       __2printf
                  |L26.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;125
00004e  dbee              BLT      |L26.46|
;;;131                nBytes--;
;;;132            }
;;;133            nIdx += 16;
;;;134            printf("\n");
000050  a00d              ADR      r0,|L26.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L26.88|
000058  2e00              CMP      r6,#0                 ;119
00005a  dcd7              BGT      |L26.12|
;;;135        }
;;;136        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L26.136|
000062  f7ffbffe          B.W      __2printf
;;;137    }
;;;138    
                          ENDP

000066  0000              DCW      0x0000
                  |L26.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L26.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L26.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L26.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L26.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L26.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;898    
;;;899    int main()
000000  f7fffffe          BL       SYS_Init
;;;900    {	
;;;901        SYS_Init();
;;;902    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;903    
;;;904    	LED_Init();
000008  f7fffffe          BL       LED_Init
;;;905    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;906    
;;;907    	SpiFlash_Init();
000010  f7fffffe          BL       SpiFlash_Init
;;;908    
;;;909    
;;;910        /* Got no where to go, just loop forever */
;;;911        while(1)
;;;912        {
;;;913    //		TIMER0_Polling(1000);
;;;914    
;;;915    		if (is_flag_set(flag_uart_rx))
000014  4903              LDR      r1,|L27.36|
                  |L27.22|
000016  6848              LDR      r0,[r1,#4]  ; BitFlag
000018  07c2              LSLS     r2,r0,#31
00001a  d0fc              BEQ      |L27.22|
;;;916    		{
;;;917    			set_flag(flag_uart_rx,DISABLE);
00001c  f0200001          BIC      r0,r0,#1
000020  6048              STR      r0,[r1,#4]  ; BitFlag
000022  e7f8              B        |L27.22|
;;;918    //			UARTx_Process();
;;;919    		}
;;;920    	
;;;921        }
;;;922    
;;;923    }
;;;924    
                          ENDP

                  |L27.36|
                          DCD      ||.data||

                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;84     
;;;85     void reset_buffer(uint8_t *pucBuff, int nBytes)
000000  2200              MOVS     r2,#0
;;;86     {
;;;87     	#if 1
;;;88         uint16_t i = 0;	
000002  4613              MOV      r3,r2
000004  e002              B        |L28.12|
                  |L28.6|
;;;89         for ( i = 0; i < nBytes; i++)
;;;90         {
;;;91             pucBuff[i] = 0x00;
000006  5483              STRB     r3,[r0,r2]
000008  1c52              ADDS     r2,r2,#1
00000a  b292              UXTH     r2,r2                 ;89
                  |L28.12|
00000c  428a              CMP      r2,r1                 ;89
00000e  dbfa              BLT      |L28.6|
;;;92         }	
;;;93     	#else	//extra 20 bytes , with <string.h>
;;;94     	memset(pucBuff, 0, nBytes * (sizeof(pucBuff[0]) ));
;;;95     	#endif
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TxBuffer
                          %        256
                  RxBuffer
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  SPI_FLASH_page_counter
000000  00                DCB      0x00
                  ||cnt||
000001  00                DCB      0x00
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_TxBuffer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____REVSH|
#line 402
|__asm___6_main_c_TxBuffer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____RRX|
#line 587
|__asm___6_main_c_TxBuffer____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
